---
title: 排序相关算法
categories:
  - Algorithm
date: 2017-10-02 16:03:09
tags: Algorithm
---
## 一. 简介
根据维基百科的定义：在计算机科学与数学中，一个排序算法（英语：Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种算法。最常用到的排序方式是数值顺序以及字典顺序。有效的排序算法在一些算法（例如搜索算法与合并算法）中是重要的，如此这些算法才能得到正确解答。排序算法也用在处理文字数据以及产生人类可读的输出结果。基本上，排序算法的输出必须遵守下列两个原则：
1. 输出结果为递增序列（递增是针对所需的排序顺序而言）
2. 输出结果是原输入的一种排列、或是重组
下图为排序相关算法总结图：
{% asset_img 排序算法总结.png 排序算法总结 %}

## 二. 相关算法
排序算法是最基本最常用的算法，不同的排序算法在不同的场景或应用中会有不同的表现，我们需要对各种排序算法熟练才能将它们应用到实际当中，才能更好地发挥它们的优势。以下是对各种排序算法的介绍及代码实现：

排序算法大体分为四类：

**1. 简单排序**

插入排序和选择排序是比较简单的排序算法，适合对小数据集进行排序，在遇到大数据集时效率非常低下

* 插入排序(Insertion Sort)
* 选择排序(Selection Sort)

**2. 高效排序**

高效率排序算法包括时间复杂度可以达到O(nlogn)的算法。

* 合并排序(Merge Sort)
* 堆排序(Heap Sort)
* 快速排序(Quick Sort)

**3. 冒泡排序及相关引申排序算法**

冒泡排序及其引申排序算法，通常比较简单但是效率低下。

* 冒泡排序(Bubble Sort)
* 希尔排序(Shell Sort)
* 梳排序（Comb sort）

**4. 分布式排序**

分布式排序算法可以允许输入数据集分布式的被处理，然后合并输出到结果中。适合遇到一台电脑处理不了的超大数据集时，进行分布式排序并合并成结果。

* 计数排序(Counting Sort)
* 桶排序(Bucket Sort)
* 基数排序（Radix sort）

以下是对各种排序算法的详细介绍：

### 1. 冒泡排序(Bubble Sort)
#### 简介
冒泡排序是最简单的排序之一，其大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，因此而得名
#### 算法原理
相邻的数据进行两两比较，小数放在前面，大数放在后面，这样一趟下来，最小的数就被排在了第一位，第二趟也是如此，如此类推，直到所有的数据排序完成
#### 复杂度
时间复杂度为O(n^2)，空间复杂度为O(1). 算法稳定
#### 代码实现

### 2. 选择排序(Selection Sort)
#### 简介
选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。
#### 算法原理
先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
#### 复杂度
选择排序的时间复杂度为O(n^2)，空间复杂度为O(1). 算法不稳定
#### 代码实现

### 3. 插入排序(Insertion Sort)
#### 简介
插入排序不是通过交换位置而是通过比较找到合适的位置插入元素来达到排序的目的的。
#### 算法原理
将数据分为两部分，有序部分与无序部分，一开始有序部分包含第1个元素，依次将无序的元素插入到有序部分，直到所有元素有序。插入排序又分为直接插入排序、二分插入排序、链表插入等，这里只讨论直接插入排序。
#### 复杂度
时间复杂度为O(n^2)，空间复杂度为O(1)。算法稳定
#### 代码实现

### 4. 快速排序(Quick Sort)
#### 简介
快速排序是目前在实践中非常高效的一种排序算法，它不是稳定的排序算法
#### 算法原理
通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
#### 复杂度
平均时间复杂度为O(nlogn)，最差情况下复杂度为O(n^2)，空间复杂度为O(logn)。算法不稳定
#### 代码实现

### 5. 归并排序(Merge Sort)
#### 简介
归并排序是另一种不同的排序方法，因为归并排序使用了递归分治的思想，所以理解起来比较容易
#### 算法原理
先递归划分子问题，然后合并结果。把待排序列看成由两个有序的子序列，然后合并两个子序列，然后把子序列看成由两个有序序列。。。。。倒着来看，其实就是先两两合并，然后四四合并。。。最终形成有序序列。
#### 复杂度
空间复杂度为O(n)，时间复杂度为O(nlogn). 算法稳定
#### 代码实现

### 6. 堆排序(Heap Sort)
#### 简介
堆排序是借助堆来实现的选择排序，思想同简单的选择排序，以下以大顶堆为例。注意：如果想升序排序就使用大顶堆，反之使用小顶堆。原因是堆顶元素需要交换到序列尾部。


#### 算法原理
首先，实现堆排序需要解决两个问题：

1. 如何由一个无序序列键成一个堆？

2. 如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？

第一个问题，可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。

第二个问题，怎么调整成堆？首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。

从一个无序序列建堆的过程就是一个反复筛选的过程。若将此序列看成是一个完全二叉树，则最后一个非终端节点是n/2取底个元素，由此筛选即可。举个栗子：

49,38,65,97,76,13,27,49序列的堆排序建初始堆和调整的过程如下：

{% asset_img 堆排序.png 堆排序 %}

#### 复杂度
时间复杂度为O(nlogn)，空间复杂度为O(1). 算法不稳定
#### 代码实现

### 7. 希尔排序(Shell Sort)
#### 简介
希尔排序是插入排序的一种高效率的实现，也叫缩小增量排序。简单的插入排序中，如果待排序列是正序时，时间复杂度是O(n)，如果序列是基本有序的，使用直接插入排序效率就非常高。希尔排序就利用了这个特点。
#### 算法原理
先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序。
{% asset_img 希尔排序.png 希尔排序 %}
从上述排序过程可见，希尔排序的特点是，子序列的构成不是简单的逐段分割，而是将某个相隔某个增量的记录组成一个子序列。如上面的例子，第一堂排序时的增量为5，第二趟排序的增量为3。由于前两趟的插入排序中记录的关键字是和同一子序列中的前一个记录的关键字进行比较，因此关键字较小的记录就不是一步一步地向前挪动，而是跳跃式地往前移，从而使得进行最后一趟排序时，整个序列已经做到基本有序，只要作记录的少量比较和移动即可。因此希尔排序的效率要比直接插入排序高。
#### 复杂度
时间复杂度为O(nlogn)，空间复杂度为O(1). 算法不稳定
#### 代码实现

### 8. 基数排序(Radix Sort)
#### 简介
基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）, 排序器每次只能看到一个列。它是基于元素值的每个位上的字符来排序的。 对于数字而言就是分别基于个位，十位， 百位或千位等等数字来排序。

基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。
#### 算法原理
它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。

基数排序按照优先从高位或低位来排序有两种实现方案：

* MSD（Most significant digital） 从最左侧高位开始进行排序。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。MSD方式适用于位数多的序列。

* LSD （Least significant digital）从最右侧低位开始进行排序。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。LSD方式适用于位数少的序列。

{% asset_img 基数排序.gif 基数排序 %}
#### 复杂度
时间复杂度为O(n) (实际上是O(d(n+k)) d是位数)，空间复杂度为O(n). 算法稳定
#### 代码实现

### 9. 计数排序(Counting sort)
#### 简介
如果在排序的时候就知道他的位置，那不就是扫描一遍，把他放入他应该的位置不就可以了。 要知道他的位置，我们只需要知道有多少不大于他就可以了。当然，计数排序只有在待排序数组满足一定条件下才能使用。
#### 算法原理
假设我们有一个待排序的整数序列A，其中元素的最小值不小于0，最大值不超过K。建立一个长度为K的线性表C，用来记录不大于每个值的元素的个数。

算法思路如下：

扫描序列A，以A中的每个元素的值为索引，把出现的个数填入C中。此时C[i]可以表示A中值为i的元素的个数。
对于C从头开始累加，使C[i]<-C[i]+C[i-1]。这样，C[i]就表示A中值不大于i的元素的个数。
按照统计出的值，输出结果。

优点：不需要比较函数，利用地址偏移，对范围固定在[0,k]的整数排序的最佳选择。是排序字节串最快的排序算法。

缺点：由于用来计数的数组的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。
#### 复杂度
时间复杂度为O(n+k)，空间复杂度为O(n+k). 算法稳定
#### 代码实现

### 10. 桶排序(Bucket Sort)
#### 简介
桶排序算是计数排序的一种改进和推广，但是网上有许多资料把计数排序和桶排序混为一谈。其实桶排序要比计数排序复杂许多。
#### 算法原理
假设有一组长度为N的待排关键字序列K[1....n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]….B[M]中的全部内容即是一个有序序列。bindex=f(key) 其中，bindex 为桶数组B的下标(即第bindex个桶), k为待排序列的关键字。桶排序之所以能够高效，其关键在于这个映射函数，它必须做到：如果关键字k1<k2，那么f(k1)<=f(k2)。也就是说B(i)中的最小数据都要大于B(i-1)中最大数据。很显然，映射函数的确定与数据本身的特点有很大的关系。

举个栗子：

{% asset_img 桶排序.gif 桶排序 %}

假如待排序列K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序后得到如图所示。只要顺序输出每个B[i]中的数据就可以得到有序序列了。

桶排序分析：

桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，希尔排序中的子序列，归并排序中的子问题，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。
#### 复杂度
桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。 当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。
#### 代码实现

## 三. 代码
本文中所有代码，可访问Github获取：[SortingAlgorithms.java](https://github.com/sealyu/algorithm/tree/master/AlgorithmTests/src/main/java/com/haiboyu/algorithm/sort)

## 四. 参考文献
1. [各种排序算法总结](http://www.jianshu.com/p/f5baf7f27a7e)
2. [排序算法](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)
3. [面试中的 10 大排序算法总结](https://github.com/francistao/LearningNotes/blob/master/Part3/Algorithm/Sort/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%2010%20%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.md)
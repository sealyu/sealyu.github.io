---
title: 二叉树相关算法
categories:
  - Algorithm
date: 2017-10-02 16:03:23
tags: Algorithm
---
## 简介
根据维基百科的定义：在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支(不存在分支度大于2的节点)的树结构。通常分支被称作“左子树”和“右子树”。二叉树的分支具有左右次序，不能颠倒。

二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉查找树和二元堆积，并应用于高效率的搜索和排序。

本文中所有二叉树代码都使用一下结构代表树节点：

	/**
 	* This class describes a node of the binary tree
 	* @author Haibo Yu on 10/08/2017.
 	*/
	public class BinaryTreeNode {
	    private int value;
	    private BinaryTreeNode leftChild;
	    private BinaryTreeNode rightChild;
	    ....
	}

## 相关算法
### 1. 求二叉树中的节点个数
**分析：** 

可以通过递归的方法：

1. 如果二叉树为空，节点个数为0
2. 如果二叉树不为空，二叉树节点个数 = 左子树节点个数 + 右子树节点个数 + 1

**代码如下：** 
	
	/**
     * Given a root node of a binary tree, get the node count
     * @param rootNode The root node of the binary tree
     * @return The count of the nodes in the binary tree
     */
    public int getNodeCountOfBinaryTree(BinaryTreeNode rootNode){
        if(null == rootNode){
            return 0;
        }else{
            return getNodeCountOfBinaryTree(rootNode.getLeftChild()) + getNodeCountOfBinaryTree(rootNode.getRightChild()) + 1;
        }
    }

### 2. 求二叉树的深度
**分析：** 

递归解法：

1. 如果二叉树为空，二叉树的深度为0
2. 如果二叉树不为空，二叉树的深度 = max(左子树深度， 右子树深度) + 1

**代码如下：** 

	/**
     * Given a root node of a binary tree, get the tree depth
     * @param rootNode The root node of the binary tree
     * @return The depth of the binary tree
     */
    public int getDepthOfBinaryTree(BinaryTreeNode rootNode){
        if(null == rootNode){
            return 0;
        }else{
            int leftSubTreeDepth = getDepthOfBinaryTree(rootNode.getLeftChild());
            int rightSubTreeDepth = getDepthOfBinaryTree(rootNode.getRightChild());
            return  (leftSubTreeDepth > rightSubTreeDepth )?(leftSubTreeDepth + 1):(rightSubTreeDepth + 1);
        }
    }

### 3. 前序遍历，中序遍历，后序遍历

**分析：** 

前序遍历递归解法：

（1）如果二叉树为空，空操作

（2）如果二叉树不为空，访问根节点，前序遍历左子树，前序遍历右子树

中序遍历递归解法

（1）如果二叉树为空，空操作。

（2）如果二叉树不为空，中序遍历左子树，访问根节点，中序遍历右子树

后序遍历递归解法

（1）如果二叉树为空，空操作

（2）如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根节点

**代码如下：** 

这些操作比较简单，类似于求深度和统计节点数，所以这里就不加了。

### 4. 分层遍历二叉树（按层次从上往下，从左往右）
**分析：** 

相当于广度优先搜索，使用队列实现。队列初始化，将根节点压入队列。当队列不为空，进行如下操作：弹出一个节点，访问，若左子节点或右子节点不为空，将其压入队列。

**代码如下：** 
	
	/**
     * Given a root node of a binary tree, iterate the tree by every level
     * @param rootNode The root node of the binary tree
     */
    public void iterateBinaryTreeByLevel(BinaryTreeNode rootNode){
        if(null == rootNode){
            return ;
        }

        Queue<BinaryTreeNode> nodes = new LinkedList<>();
        nodes.offer(rootNode);
        while(!nodes.isEmpty()){
            BinaryTreeNode curNode = nodes.poll();
            System.out.println("Pop Node:"+curNode.getValue());
            if(null != curNode.getLeftChild()){
                nodes.offer(curNode.getLeftChild());
            }
            if(null != curNode.getRightChild()){
                nodes.offer(curNode.getRightChild());
            }
        }
    }

### 5. 将二叉查找树变为有序的双向链表
二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树（英语：ordered binary tree），排序二叉树（英语：sorted binary tree），是指一棵空树或者具有下列性质的二叉树：

* 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
* 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
* 任意节点的左、右子树也分别为二叉查找树；
* 没有键值相等的节点。

二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。


**题目描述：** 

输入一棵二叉搜索树，现在要将该二叉搜索树转换成一个排序的双向链表。而且在转换的过程中，不能创建任何新的结点，只能调整树中的结点指针的指向来实现。

**分析：** 

使用递归算法处理。左子树转换后的最后一个节点为根节点在双向链表中的前一个节点，根节点的后一个节点为右子树转换后的第一个节点。

**解题思路：**

* 如果左子树不为null，处理左子树

a）递归转化左子树为双向链表；

b）找出根结点的前驱节点（是左子树的最右的节点）

c）将上一步找出的节点和根结点连接起来

* 如果右子树不为null，处理右子树（和上面的很类似）

a）递归转化右子树为双向链表；

b）找出根结点的后继节点（是右子树的最左的节点）

c）将上一步找出的节点和根结点连接起来

找到最左边的节点并返回

**代码如下：** 

	/**
     * Convert a binary search tree into a doubly linked list, the requirement is not to create
     * new node, only change the pointers based on the existing node.
     * @param rootNode The root node of the binary search tree.
     * @return The head node of the doubly linked list.
     */
    public void convertBinaryTreeToDoublyLinkedList(BinaryTreeNode rootNode){
        if(null == rootNode){
            return;
        }

        if(null != rootNode.getLeftChild()){
            convertBinaryTreeToDoublyLinkedList(rootNode.getLeftChild());
            BinaryTreeNode biggestNode = findBiggestNodeInTheTree(rootNode.getLeftChild());
            biggestNode.setRightChild(rootNode);
            rootNode.setLeftChild(biggestNode);
        }
        if(null != rootNode.getRightChild()){
            convertBinaryTreeToDoublyLinkedList(rootNode.getRightChild());
            BinaryTreeNode smallestNode = findSmalledNodeInTheTree(rootNode.getRightChild());
            smallestNode.setLeftChild(rootNode);;
            rootNode.setRightChild(smallestNode);
        }
    }

    /**
     * Find the smallest node in the binary search tree
     * @param rootNode The root node
     * @return The smallest node in the binary search tree
     */
    private BinaryTreeNode findSmalledNodeInTheTree(BinaryTreeNode rootNode){
        while(rootNode.getLeftChild() != null){
            rootNode = rootNode.getLeftChild();
        }
        return rootNode;
    }

    /**
     * Find the biggest node in the binary search tree
     * @param rootNode The root node
     * @return The biggest node in the binary search tree
     */
    private BinaryTreeNode findBiggestNodeInTheTree(BinaryTreeNode rootNode){
        while(rootNode.getRightChild() != null){
            rootNode = rootNode.getRightChild();
        }
        return rootNode;
    }

### 6. 求二叉树第K层的节点个数
**分析：** 

递归解法：

（1）如果二叉树为空或者k<1返回0

（2）如果二叉树不为空并且k==1，返回1

（3）如果二叉树不为空且k>1，返回左子树中k-1层的节点个数与右子树k-1层节点个数之和

**代码如下：** 

	/**
     * Get the total node number of the kth level of the binary tree
     * @param rootNode The root node of the binary tree
     * @param k The level number
     * @return The total node number of the kth level.
     */
    public int getNodeNumberForKthLevel(BinaryTreeNode rootNode, int k){
        if(null == rootNode || k<1){
            return 0;
        }

        if(k ==1){
            return 1;
        }

        int totalLeft = getNodeNumberForKthLevel(rootNode.getLeftChild(),k-1);
        int totalRight = getNodeNumberForKthLevel(rootNode.getRightChild(),k-1);
        return totalLeft + totalRight;
    }

### 7. 求二叉树中叶子节点的个数
**分析：** 

**代码如下：** 

### 8. 判断两棵二叉树是否结构相同
**分析：** 

**代码如下：** 

### 9. 判断二叉树是不是平衡二叉树
**分析：** 

**代码如下：** 

### 10. 求二叉树的镜像
**分析：** 

**代码如下：** 

### 11. 求二叉树中两个节点的最低公共祖先节点
**分析：** 

**代码如下：** 

### 12. 求二叉树中节点的最大距离
**分析：** 

**代码如下：** 

### 13. 由前序遍历序列和中序遍历序列重建二叉树
**分析：** 

**代码如下：** 

### 14. 判断二叉树是不是完全二叉树
**分析：** 

**代码如下：** 


## 参考文献
1. [各种排序算法总结](http://www.jianshu.com/p/f5baf7f27a7e)
2. [二叉树](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91)
3. [轻松搞定面试中的二叉树题目](http://blog.csdn.net/walkinginthewind/article/details/7518888)

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Microsoft Interview Algorithm questions]]></title>
    <url>%2Fen%2F2018%2F05%2F01%2FMicrosoft-Interview-Algorithm-questions%2F</url>
    <content type="text"><![CDATA[Question1:Merge 2 sorted linked list(In ascendant order, duplicate allowed)do not use recursion.It takes in two already sorted linked lists (in ascendant order, duplicates allowed) and is supposed to merge them into a single sorted linked list (in ascendant order, duplicates allowed) and returns the new head. Solution1:This is a simple algorithm quesiton, we can definitely make the time complexity O(n). /** * Merge 2 sorted linked list into a single sorted linked list. * @param startNode1 The start node of linked list 1 * @param startNode2 The start node of linked list 2 * @return The merged sorted linked list */ private Node mergeSortedLinkedList(Node startNode1, Node startNode2){ Node headerNode = new Node(0); Node lastNode = headerNode; //Loop and compare the node between list 1 and list 2 until any of them end. while (startNode1 != null &amp;&amp; startNode2 != null) { if (startNode1.data &lt; startNode2.data) { lastNode.next = startNode1; startNode1 = startNode1.next; } else { lastNode.next = startNode2; startNode2 = startNode2.next; } lastNode = lastNode.next; } //Append the un-finished one to the result if (startNode1 != null) { lastNode.next = startNode1; } else { lastNode.next = startNode2; } return headerNode.next; } Question2:Given a list of scope and value pair like ([0,100] 1, [20,50) 3, [30,50] -3, (50,60] 2), find the maximum overlap value. Make the time complexity O(n) Solution2:This is similar to the problem referred in Maximum number of overlapping intervals – Merge Overlapping Intervals – Max Task Load Another version of this problem could be – Given a list of n Jobs with start time, end time and CPU load when it is active at any moment. If all the jobs are running at the same machine then find the maximum CPU load at any time. For example, let’s define a job as a tuple of (start_time, end_time, weight) where weight is the load of that job at any time when active. Then, jobs = {(3, 7, 4), (1, 3, 6), (4, 9, 5)} –&gt; max load = 10. jobs = {(3, 7, 4), (1, 3, 6), (4, 9, 5), (10, 11, 11)} –&gt; max load = 11. jobs = {(3, 7, 4), (1, 3, 6), (4, 9, 5), (10, 11, 11),(3, 4, 2)} –&gt; max load = 12. Note that, this is similar to finding maximum overlap where we maximize total weight (i.e. load) instead of maximizing total number of overlaps. We can similarly sort the jobs based on start and end time in separate arrays and then find overlap incrementally as we did previously. Each time we have one more overlapping interval we update current load with the current job and keep updating global max. When we see an interval to end then we need to subtract the load of this job from the running load. Below is a O(nLogn) time algorithm to find the max total load of all the jobs active at certain time. public static int maxLoad(Job[] jobs){ int maxLoad = 0; int curLoad = 0; Job[] start = Arrays.copyOf(jobs, jobs.length); Job[] end = Arrays.copyOf(jobs, jobs.length); Arrays.sort(start, new Comparator&lt;Job&gt;() { @Override public int compare(Job o1, Job o2) { return Integer.compare(o1.start, o2.start); } }); Arrays.sort(end, new Comparator&lt;Job&gt;() { @Override public int compare(Job o1, Job o2) { return Integer.compare(o1.finish , o2.finish); } }); int i = 0, j = 0; while(i &lt; start.length &amp;&amp; j &lt; end.length){ if(start[i].start &lt;= end[j].finish){ curLoad += start[i].weight; maxLoad = Math.max(maxLoad, curLoad); i++; } else{ curLoad -= end[j].weight; j++; } } return maxLoad; } Question3:Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3 Example 2: Input: [3,4,-1,1] Output: 2 Example 3: Input: [7,8,9,11,12] Output: 1 Note: Your algorithm should run in O(n) time and uses constant extra space. Solution3:A simple way to make it work is to sort the array using QuickSort and loop the array to find the first missing positive number. But the time complexity then becomes O(N*LogN) and does not meet the requirement.Then the solution would be to use the index of the array: First loop the array, compare the value of the postion and it’s index, try to put all numbers to the place so array[i] = i+1. Then loop the array and the first element whose value does not equal index+1 is the missing value. If all matchs, then the length+1 should be the first one missing. public int firstMissingPositive(int[] nums) { int len = nums.length; //Loop the array, only process the positive number, put all the value to the index to make it nums[i] = i for(int i = 0; i &lt; len; i++){ while(nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[nums[i] - 1] != nums[i]){ swap(nums, i, nums[i] - 1); } } //The first index whose value does not equal index+1 is the missing value for(int i = 0; i &lt; len; i++){ if(nums[i] != i + 1) return i + 1; } //If all matchs, then the length + 1 should be the first missing postive number return len + 1; } private void swap(int[] array, int start, int end){ int temp = array[start]; array[start] = array[end]; array[end] = temp; } Question4:Given a set of integer A(s1,s2,s3,…), S is A’s sub set. Given S1|S2|S3’|.. =X(按位或), find after deleting number N from A to make all S can’t generate Y. Make it O(n). Solution4: Get the positions of the bits of Y which equals Create a HashTable with length 32, every key stores the number of values whose bit on this key equal 1. Loop all integer numbers of A, for every value, update the HashTable, for all postison of the bits equal 1, update the hashtable[position]++ Find the minimum value of the Hashtable, is the number of smallest number of elements need to be deleted. After deleting these elements, it will not be able to generate the Y, because there’s 1 bit which can’t be 1. Question5:Convex hull problem: Given a plane and many points, find the convex hull so all points either inside of the hull or on the edge. Input: A set of points Output: The set of points on the edge. Solution5:The detail solution can ben found GrahamScan.java Reference Maximum number of overlapping intervals – Merge Overlapping Intervals – Max Task Load [Convex Hull] (https://en.wikipedia.org/wiki/Convex_hull) [Graham scan] (https://en.wikipedia.org/wiki/Graham_scan) GrahamScan.java 凸包（Convex Hull）]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript call by value/reference]]></title>
    <url>%2Fen%2F2018%2F02%2F13%2FJavascript-call-by-valure-reference%2F</url>
    <content type="text"><![CDATA[In this post, we will look into pass by value and pass by reference in Javascript. Let’s see what is pass by value and pass by reference before looking into its javascript context. Pass by Value: In Pass by Value, Function is called by directly passing the value of the variable as the argument. Changing the argument inside the function doesn’t affect the variable passed from outside the function. Javascript always pass by value so changing the value of the variable never changes the underlying primitive (String or number). function callByValue(varOne, varTwo) { console.log(&quot;Inside Call by Value Method&quot;); varOne = 100; varTwo = 200; console.log(&quot;varOne =&quot; + varOne +&quot;varTwo =&quot; +varTwo); } let varOne = 10; let varTwo = 20; console.log(&quot;Before Call by Value Method&quot;); console.log(&quot;varOne =&quot; + varOne +&quot;varTwo =&quot; +varTwo); callByValue(varOne, varTwo) console.log(&quot;After Call by Value Method&quot;); console.log(&quot;varOne =&quot; + varOne +&quot;varTwo =&quot; +varTwo); output will be : Before Call by Value Method varOne =10 varTwo =20 Inside Call by Value Method varOne =100 varTwo =200 After Call by Value Method varOne =10 varTwo =20 However, when a variable refers to an object which includes array, the value is the reference to the object. Pass by Reference: In Pass by Reference, Function is called by directly passing the reference/address of the variable as the argument. Changing the argument inside the function affect the variable passed from outside the function. In Javascript objects and arrays follows pass by reference. function callByReference(varObj) { console.log(&quot;Inside Call by Reference Method&quot;); varObj.a = 100; console.log(varObj); } let varObj = {a:1}; console.log(&quot;Before Call by Reference Method&quot;); console.log(varObj); callByReference(varObj) console.log(&quot;After Call by Reference Method&quot;); console.log(varObj); output will be : Before Call by Reference Method {a: 1} Inside Call by Reference Method {a: 100} After Call by Reference Method {a: 100} so if we are passing object or array as an argument to the method, then there is a possibility that value of the object can change. Reference Pass By Value And Pass By Reference In JavaScript]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pandas Selection by Position]]></title>
    <url>%2Fen%2F2017%2F12%2F27%2FPandas-Selection-by-Position%2F</url>
    <content type="text"><![CDATA[There are multiple ways to select and index rows and columns from Pandas DataFrames: Selection Options There’s three main options to achieve the selection and indexing activities in Pandas, which can be confusing. The three selection cases and methods covered in this post are: Selecting data by row numbers (.iloc). Purely integer-location based indexing for selection by position. It is primarily integer position based (from 0 to length-1 of the axis), but may also be used with a boolean array. Selecting data by label or by a conditional statment (.loc). It is primarily label based, but may also be used with a boolean array Selecting in a hybrid approach (.ix) (now Deprecated in Pandas 0.20.1) Below are some examples: iloc: # Single selections using iloc and DataFrame # Rows: data.iloc[0] # first row of data frame (Aleshia Tomkiewicz) - Note a Series data type output. data.iloc[1] # second row of data frame (Evan Zigomalas) data.iloc[-1] # last row of data frame (Mi Richan) # Columns: data.iloc[:,0] # first column of data frame (first_name) data.iloc[:,1] # second column of data frame (last_name) data.iloc[:,-1] # last column of data frame (id) # Multiple row and column selections using iloc and DataFrame data.iloc[0:5] # first five rows of dataframe data.iloc[:, 0:2] # first two columns of data frame with all rows data.iloc[[0,3,6,24], [0,5,6]] # 1st, 4th, 7th, 25th row + 1st 6th 7th columns. data.iloc[0:5, 5:8] # first 5 rows and 5th, 6th, 7th columns of data frame (county -&gt; phone1). loc # Select rows with index values &apos;Andrade&apos; and &apos;Veness&apos;, with all columns between &apos;city&apos; and &apos;email&apos; data.loc[[&apos;Andrade&apos;, &apos;Veness&apos;], &apos;city&apos;:&apos;email&apos;] # Select same rows, with just &apos;first_name&apos;, &apos;address&apos; and &apos;city&apos; columns data.loc[&apos;Andrade&apos;:&apos;Veness&apos;, [&apos;first_name&apos;, &apos;address&apos;, &apos;city&apos;]] # Change the index to be based on the &apos;id&apos; column data.set_index(&apos;id&apos;, inplace=True) # select the row with &apos;id&apos; = 487 data.loc[487] Reference Pandas Data Selection]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Probability - Boys and girls]]></title>
    <url>%2Fen%2F2017%2F11%2F10%2FProbability-Boys-and-gilrs%2F</url>
    <content type="text"><![CDATA[Questions:In a country where everyone wants a boy, each family continues having babies till they have a boy. After some time, what is the proportion of boys to girls in the country? (Assuming probability of having a boy or a girl is the same) Solution:Assume finally the numbers of boys is C. Then: Number of girls = 0*(Probability of 0 girls) + 1*(Probability of 1 girl) + 2*(Probability of 2 girls) + … Number of girls = 0*(C*1/2) + 1*(C*1/2*1/2) + 2*(C*1/2*1/2*1/2) + … Number of girls = 0 + C/4 + 2*C/8 + 2*C/16 + … Number of girls = C (using mathematical formulas; it becomes apparent if you just sum up the first 4-5 terms) Without using math:Logically thinking, It stays 50%. As long as the chance for each child is 50%, it won’t change. Using math: AnswerBoys and Girls ratio: 1:1]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Design Pattern Note-State Pattern]]></title>
    <url>%2Fzh-Hans%2F2017%2F11%2F09%2FDesign-Pattern-Note-State-Pattern%2F</url>
    <content type="text"><![CDATA[一. 定义状态模式(State Pattern) ：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。 状态模式用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。当系统中某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化，对于客户端而言，无须关心对象状态的转换以及对象所处的当前状态，无论对于何种状态的对象，客户端都可以一致处理。 模式结构 ： 状态模式包含如下角色： Context: 上下文类 环境类又称为上下文类，它是拥有多种状态的对象。由于环境类的状态存在多样性且在不同状态下对象的行为有所不同，因此将状态独立出去形成单独的状态类。在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象。 State: 抽象状态类 它用于定义一个接口以封装与环境类的一个特定状态相关的行为，在抽象状态类中声明了各种不同状态对应的方法，而在其子类中实现类这些方法，由于不同状态下对象的行为可能不同，因此在不同子类中方法的实现可能存在不同，相同的方法可以写在抽象状态类中。 ConcreteState: 具体状态类 它是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。 二. 常用场景在以下情况下可以使用状态模式： 对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。 代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。 主要应用场景： 如果项目中存在太多的 if {…} elseif {…} else {…} 。那么你应该考虑状态模式。我觉得这个是重点考虑对象 如果每个状态中处理的业务逻辑特别复杂·那么建议考虑这种方式 spring中单独实现了一个状态机：https://projects.spring.io/spring-statemachine/ 三. 优缺点优点 封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中。 将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。 允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起。 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 缺点 状态模式的使用必然会增加系统中类和对象的个数，导致系统运行开销增大。 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度。 状态模式对“开闭原则”的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。 参考文献 设计模式(行为型)之状态模式(State Pattern) php设计模式：状态模式的使用场景]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Multiple columns search by same keyword in SQL]]></title>
    <url>%2Fen%2F2017%2F11%2F09%2FMultiple-columns-search-by-same-keyword-in-SQL%2F</url>
    <content type="text"><![CDATA[Sometime we have requirement to do fuzzy search in multiple columns of a database table.For example: A Person table has below columns: Id | Name | CellPhone | WorkPhone | HomePhone Try to search the pearson with any phoneNumber has 666. The normal way might be: select * from Person where cellPhone like &apos;%666%&apos; or workPhone like &apos;%666%&apos; or homePhone like &apos;%666%&apos; This gonna be a performance issue if the rows are huge in the table. A better way to do this: select * from Person where contact(cellPhone, &apos;/&apos;, workPhone, &apos;/&apos;, homePhone) like &apos;%666%&apos;]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Georgia Tech OMSCS]]></title>
    <url>%2Fzh-Hans%2F2017%2F10%2F17%2FGeorgia-Tech-OMSCS%2F</url>
    <content type="text"><![CDATA[今天终于收到了Georgia Tech的录取通知书，不枉近半年的努力。 年初听到同事推荐Georgia Tech的OMSCS项目, 作为一个Computer Science在US News Ranking排名第9的专业，刚开始申请的时候确实没什么信心。不过由于online的优点和超高的性价比（学费约7000美元），还是决定申请: 5月份开始准备托福考试，开始了没日没夜背单词刷题的生活 6月24号参加了托福考试，因为听力没把握好时间，最后一篇4道题目没有做，总分只拿到96分，离102的分数线还是低了6分。比较沮丧，放弃申请 8月份国内归来，报着试试看的想法，重新开始申请 一周内写完简历、Background、CareerObjective、StateOfPurpose，找同事写了3封Recommendation letter，8月18号提交申请 10月10号收到GT的decision letter 10月17号收到GT的final admission letter. 现在准备开始未来两到三年没日没夜一边工作一边读书的生活了。。。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树相关算法]]></title>
    <url>%2Fzh-Hans%2F2017%2F10%2F02%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一. 简介根据维基百科的定义：在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支(不存在分支度大于2的节点)的树结构。通常分支被称作“左子树”和“右子树”。二叉树的分支具有左右次序，不能颠倒。 二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉查找树和二元堆积，并应用于高效率的搜索和排序。 本文中所有二叉树代码都使用一下结构代表树节点： /** * This class describes a node of the binary tree * @author Haibo Yu on 10/08/2017. */ public class BinaryTreeNode { private int value; private BinaryTreeNode leftChild; private BinaryTreeNode rightChild; .... } 二. 实际应用 B+和B-树在文件系统中的应用 红黑树用于调度、虚拟内存管理、跟踪文件描述符和目录条目等 Radix树，用于内存管理、NFS相关查找和网络相关的功能 二叉树搜索用于中断处理、登记缓存查找等 Merkle 树用于最近比较流行的区块链技术。 三. 相关算法1. 求二叉树中的节点个数分析： 可以通过递归的方法： 如果二叉树为空，节点个数为0 如果二叉树不为空，二叉树节点个数 = 左子树节点个数 + 右子树节点个数 + 1 代码如下： /** * Given a root node of a binary tree, get the node count * @param rootNode The root node of the binary tree * @return The count of the nodes in the binary tree */ public int getNodeCountOfBinaryTree(BinaryTreeNode rootNode){ if(null == rootNode){ return 0; }else{ return getNodeCountOfBinaryTree(rootNode.getLeftChild()) + getNodeCountOfBinaryTree(rootNode.getRightChild()) + 1; } } 2. 求二叉树的深度分析： 递归解法： 如果二叉树为空，二叉树的深度为0 如果二叉树不为空，二叉树的深度 = max(左子树深度， 右子树深度) + 1 代码如下： /** * Given a root node of a binary tree, get the tree depth * @param rootNode The root node of the binary tree * @return The depth of the binary tree */ public int getDepthOfBinaryTree(BinaryTreeNode rootNode){ if(null == rootNode){ return 0; }else{ int leftSubTreeDepth = getDepthOfBinaryTree(rootNode.getLeftChild()); int rightSubTreeDepth = getDepthOfBinaryTree(rootNode.getRightChild()); return (leftSubTreeDepth &gt; rightSubTreeDepth )?(leftSubTreeDepth + 1):(rightSubTreeDepth + 1); } } 3. 前序遍历，中序遍历，后序遍历分析： 前序遍历递归解法： （1）如果二叉树为空，空操作 （2）如果二叉树不为空，访问根节点，前序遍历左子树，前序遍历右子树 中序遍历递归解法 （1）如果二叉树为空，空操作。 （2）如果二叉树不为空，中序遍历左子树，访问根节点，中序遍历右子树 后序遍历递归解法 （1）如果二叉树为空，空操作 （2）如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根节点 代码如下： 这些操作比较简单，类似于求深度和统计节点数，所以这里就不加了。 4. 分层遍历二叉树（按层次从上往下，从左往右）分析： 相当于广度优先搜索，使用队列实现。队列初始化，将根节点压入队列。当队列不为空，进行如下操作：弹出一个节点，访问，若左子节点或右子节点不为空，将其压入队列。 代码如下： /** * Given a root node of a binary tree, iterate the tree by every level * @param rootNode The root node of the binary tree */ public void iterateBinaryTreeByLevel(BinaryTreeNode rootNode){ if(null == rootNode){ return ; } Queue&lt;BinaryTreeNode&gt; nodes = new LinkedList&lt;&gt;(); nodes.offer(rootNode); while(!nodes.isEmpty()){ BinaryTreeNode curNode = nodes.poll(); System.out.println(&quot;Pop Node:&quot;+curNode.getValue()); if(null != curNode.getLeftChild()){ nodes.offer(curNode.getLeftChild()); } if(null != curNode.getRightChild()){ nodes.offer(curNode.getRightChild()); } } } 5. 将二叉查找树变为有序的双向链表二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树（英语：ordered binary tree），排序二叉树（英语：sorted binary tree），是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。 二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。 题目描述： 输入一棵二叉搜索树，现在要将该二叉搜索树转换成一个排序的双向链表。而且在转换的过程中，不能创建任何新的结点，只能调整树中的结点指针的指向来实现。 分析： 使用递归算法处理。左子树转换后的最后一个节点为根节点在双向链表中的前一个节点，根节点的后一个节点为右子树转换后的第一个节点。 解题思路： 如果左子树不为null，处理左子树 a）递归转化左子树为双向链表； b）找出根结点的前驱节点（是左子树的最右的节点） c）将上一步找出的节点和根结点连接起来 如果右子树不为null，处理右子树（和上面的很类似） a）递归转化右子树为双向链表； b）找出根结点的后继节点（是右子树的最左的节点） c）将上一步找出的节点和根结点连接起来 找到最左边的节点并返回 代码如下： /** * Convert a binary search tree into a doubly linked list, the requirement is not to create * new node, only change the pointers based on the existing node. * @param rootNode The root node of the binary search tree. * @return The head node of the doubly linked list. */ public void convertBinaryTreeToDoublyLinkedList(BinaryTreeNode rootNode){ if(null == rootNode){ return; } if(null != rootNode.getLeftChild()){ convertBinaryTreeToDoublyLinkedList(rootNode.getLeftChild()); BinaryTreeNode biggestNode = findBiggestNodeInTheTree(rootNode.getLeftChild()); biggestNode.setRightChild(rootNode); rootNode.setLeftChild(biggestNode); } if(null != rootNode.getRightChild()){ convertBinaryTreeToDoublyLinkedList(rootNode.getRightChild()); BinaryTreeNode smallestNode = findSmalledNodeInTheTree(rootNode.getRightChild()); smallestNode.setLeftChild(rootNode);; rootNode.setRightChild(smallestNode); } } /** * Find the smallest node in the binary search tree * @param rootNode The root node * @return The smallest node in the binary search tree */ private BinaryTreeNode findSmalledNodeInTheTree(BinaryTreeNode rootNode){ while(rootNode.getLeftChild() != null){ rootNode = rootNode.getLeftChild(); } return rootNode; } /** * Find the biggest node in the binary search tree * @param rootNode The root node * @return The biggest node in the binary search tree */ private BinaryTreeNode findBiggestNodeInTheTree(BinaryTreeNode rootNode){ while(rootNode.getRightChild() != null){ rootNode = rootNode.getRightChild(); } return rootNode; } 6. 求二叉树第K层的节点个数分析： 递归解法： （1）如果二叉树为空或者k&lt;1返回0 （2）如果二叉树不为空并且k==1，返回1 （3）如果二叉树不为空且k&gt;1，返回左子树中k-1层的节点个数与右子树k-1层节点个数之和 代码如下： /** * Get the total node number of the kth level of the binary tree * @param rootNode The root node of the binary tree * @param k The level number * @return The total node number of the kth level. */ public int getNodeNumberForKthLevel(BinaryTreeNode rootNode, int k){ if(null == rootNode || k&lt;1){ return 0; } if(k ==1){ return 1; } int totalLeft = getNodeNumberForKthLevel(rootNode.getLeftChild(),k-1); int totalRight = getNodeNumberForKthLevel(rootNode.getRightChild(),k-1); return totalLeft + totalRight; } 7. 求二叉树中叶子节点的个数分析： 递归解法： （1）如果二叉树为空，返回0 （2）如果二叉树不为空且左右子树为空，返回1 （3）如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子节点个数 代码如下： /** * Get the total leaf node number of the binary tree * @param rootNode The root node of the binary tree * @return The total leaf node number */ public int getLeafNodeNumberForBinaryTree(BinaryTreeNode rootNode){ if(null == rootNode){ return 0; } if(null == rootNode.getLeftChild() &amp;&amp; null == rootNode.getRightChild()){ return 1; } int totalLeft = getLeafNodeNumberForBinaryTree(rootNode.getLeftChild()); int totalRight = getLeafNodeNumberForBinaryTree(rootNode.getRightChild()); return totalLeft + totalRight; } 8. 判断两棵二叉树是否结构相同分析： 递归解法： （1）如果两棵二叉树都为空，返回真 （2）如果两棵二叉树一棵为空，另一棵不为空，返回假 （3）如果两棵二叉树都不为空，如果对应的左子树和右子树都同构返回真，其他返回假 代码如下： /** * Given 2 binary tree, check if they are same structure. * @param rootNode1 The root node of the 1st binary tree * @param rootNode2 The root node of the 2nd binary tree * @return If they have same strcture */ public boolean checkIfTwoBinaryTreeHaveSameStructure(BinaryTreeNode rootNode1,BinaryTreeNode rootNode2){ if(null == rootNode1 &amp;&amp; null == rootNode2){ return true; }else if(null == rootNode1 || null == rootNode2){ return false; } boolean leftEqual = checkIfTwoBinaryTreeHaveSameStructure(rootNode1.getLeftChild(), rootNode2.getLeftChild()); boolean rightEqual = checkIfTwoBinaryTreeHaveSameStructure(rootNode1.getRightChild(),rootNode2.getRightChild()); return (leftEqual &amp;&amp; rightEqual); } 9. 判断二叉树是不是平衡二叉树平衡二叉树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质： 它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树， 同时，平衡二叉树必定是二叉搜索树，反之则不一定。 平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci(斐波那契)数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。 分析： 递归解法： （1）如果二叉树为空，返回真 （2）如果二叉树不为空，如果左子树和右子树都是AVL树并且左子树和右子树高度相差不大于1，返回真，其他返回假 代码如下： /** * Given a binary tree, check if it is AVL tree. * @param rootNode The root node of the binary tree * @return If the tree is AVL tree */ public boolean checkIfAVLBinaryTree(BinaryTreeNode rootNode){ if(null == rootNode){ return true; } boolean leftAVL = checkIfAVLBinaryTree(rootNode.getLeftChild()); boolean rightAVL = checkIfAVLBinaryTree(rootNode.getRightChild()); int leftDepth = this.getDepthOfBinaryTree(rootNode.getLeftChild()); int rightDepth = this.getDepthOfBinaryTree(rootNode.getRightChild()); return (leftAVL &amp;&amp; rightAVL &amp;&amp; (Math.abs(leftDepth - rightDepth)&lt;=1)); } 10. 求二叉树的镜像分析： 递归解法： （1）如果二叉树为空，返回空 （2）如果二叉树不为空，求左子树和右子树的镜像，然后交换左子树和右子树 代码如下： /** * Given a binary tree, get it&apos;s mirror tree. * @param rootNode The root node of the binary tree * @return The mirror tree */ public BinaryTreeNode getMirrorBinaryTree(BinaryTreeNode rootNode){ if(null == rootNode){ return null; } BinaryTreeNode leftMirror = getMirrorBinaryTree(rootNode.getLeftChild()); BinaryTreeNode rightMirror = getMirrorBinaryTree(rootNode.getRightChild()); rootNode.setLeftChild(rightMirror); rootNode.setRightChild(leftMirror); return rootNode; } 11. 求二叉树中两个节点的最低公共祖先节点分析： 当节点带有parent指针时，可以方便的从给定节点遍历到根节点，经过的路径其实一条链表。因此，求最低公共祖先，就是求两链表的第一个交点。 当节点没有父指针时，使用递归解法： （1）如果两个节点分别在根节点的左子树和右子树，则返回根节点 （2）如果两个节点都在左子树，则递归处理左子树；如果两个节点都在右子树，则递归处理右子树 代码如下： /** * Given a binary tree and 2 node, get their lowest common node. * @param rootNode The root node of the binary tree * @return The mirror tree */ public BinaryTreeNode getLowestCommonNodeOfTwoNode(BinaryTreeNode rootNode, BinaryTreeNode node1, BinaryTreeNode node2){ if(null == rootNode || null == node1 || null == node2){ return null; } if(findNodeInTheTree(rootNode.getLeftChild(),node1)){ //If node1 and node2 are found separately in left and right tree,then rootNode is the lowest common node. if(findNodeInTheTree(rootNode.getRightChild(),node2)){ return rootNode; }else{ return getLowestCommonNodeOfTwoNode(rootNode.getLeftChild(),node1,node2); } }else{ if(findNodeInTheTree(rootNode.getLeftChild(),node2)){ return rootNode; }else{ return getLowestCommonNodeOfTwoNode(rootNode.getRightChild(),node1,node2); } } } /** * Check if the node is in the tree * @param rootNode The root node of the tree * @param node The node * @return If the tree has this node */ private boolean findNodeInTheTree(BinaryTreeNode rootNode, BinaryTreeNode node){ if(null == rootNode){ return false; } if(rootNode.equals(node)){ return true; } boolean findInLeft = findNodeInTheTree(rootNode.getLeftChild(),node); boolean findInRight = findNodeInTheTree(rootNode.getRightChild(),node); return findInLeft||findInRight; } 12. 求二叉树中节点的最大距离分析： 递归解法： （1）如果二叉树为空，返回0，同时记录左子树和右子树的深度，都为0 （2）如果二叉树不为空，最大距离要么是左子树中的最大距离，要么是右子树中的最大距离，要么是左子树节点中到根节点的最大距离+右子树节点中到根节点的最大距离，同时记录左子树和右子树节点中到根节点的最大距离。 代码如下： /** * Get the biggest distance between nodes of binary tree * @param rootNode The root node of the binary tree * @return The distance */ private int getBiggestDistanceBetweenNodeOfBinaryTree(BinaryTreeNode rootNode){ if(null == rootNode){ return 0; } int disLeft = getBiggestDistanceBetweenNodeOfBinaryTree(rootNode.getLeftChild()); int disRight = getBiggestDistanceBetweenNodeOfBinaryTree(rootNode.getRightChild()); int maxLeft = 0, maxRight = 0; if(null != rootNode.getLeftChild()){ maxLeft = this.getDepthOfBinaryTree(rootNode.getLeftChild())+1; } if(null != rootNode.getRightChild()){ maxRight = this.getDepthOfBinaryTree(rootNode.getRightChild())+1; } return Math.max(Math.max(disLeft,disRight),maxLeft+maxRight); } 13. 由前序遍历序列和中序遍历序列重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 分析： 在二叉树的前序遍历序列中，第一个数字总是树的根结点的值。但在中序遍历序列中，根结点的值在序列的中间，左子树的结点的值位于根结点的值的左边，而右子树的结点的值位于根结点的值的右边。因此我们需要扫描中序遍历序列，才能找到根结点的值。 前序遍历序列的第一个数字1就是根结点的值。扫描中序遍历序列，就能确定根结点的值的位置。根据中序遍历特点，在根结点的值1前面的3个数字都是左子树结点的值，位于1后面的数字都是右子树结点的值。 在二叉树的前序遍历和中序遍历的序列中确定根结点的值、左子树结点的值和右子树结点的值的步骤如下图所示： 分别找到了左、右子树的前序遍历序列和中序遍历序列，我们就可以用同样的方法分别去构建左右子树。换句话说，这是一个递归的过程。 思路总结: 先根据前序遍历序列的第一个数字创建根结点，接下来在中序遍历序列中找到根结点的位置，这样就能确定左、右子树结点的数量。在前序遍历和中序遍历的序列中划分了左、右子树结点的值之后，就可以递归地去分别构建它的左右子树。 代码如下： /** * Rebuild the binary tree based on the pre-order and middle-order output of the tree. * @param preOrderArr The pre-order array output * @param midOrderArr The middle-order array output * @return The head node of the binary tree */ public BinaryTreeNode rebuildBinaryTree(int[] preOrderArr, int[] midOrderArr){ if (preOrderArr == null || midOrderArr == null || preOrderArr.length != midOrderArr.length || preOrderArr.length &lt; 1 || midOrderArr.length &lt; 1) { return null; } return rebuildBinaryTree(preOrderArr, 0, preOrderArr.length - 1, midOrderArr, 0, midOrderArr.length -1); } /** * Recursively build the tree * @param preOrderArr The pre order array * @param preStart The start index of pre order array * @param preEnd The end index of the pre order array * @param midOrderArr The middle order array * @param midStart The start index of middle order array * @param midEnd The end index of middle order array * @return The root node of the sub tree after building. */ public BinaryTreeNode rebuildBinaryTree(int[] preOrderArr, int preStart, int preEnd, int[] midOrderArr, int midStart, int midEnd){ if (preStart &gt; preEnd) { return null; } // Get current root node int rootValue = preOrderArr[preStart]; //Get the index of current root node in the midOrderArray int indexInMid = midStart; while (indexInMid &lt;= midEnd &amp;&amp; midOrderArr[indexInMid] != rootValue) { indexInMid++; } // Create the current root node BinaryTreeNode rootNode = new BinaryTreeNode(rootValue); // Rebuild the left sub tree BinaryTreeNode leftChild = rebuildBinaryTree(preOrderArr, preStart + 1, preStart + indexInMid - midStart, midOrderArr, midStart, indexInMid - 1); //Rebuild the right sub tree BinaryTreeNode rightChild = rebuildBinaryTree(preOrderArr, preStart + indexInMid - midStart + 1, preEnd, midOrderArr, indexInMid + 1, midEnd); rootNode.setLeftChild(leftChild); rootNode.setRightChild(rightChild); return rootNode; } 14. 判断二叉树是不是完全二叉树完全二叉树(Complete Binary Tree) 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。 分析： 按层次（从上到下，从左到右）遍历二叉树，当遇到一个节点的左子树为空时，则该节点右子树必须为空，且后面遍历的节点左右子树都必须为空，否则不是完全二叉树。 代码如下： /** * Given a binary tree, check if it&apos;s complete binary tree. * @param rootNode The root node of the tree * @return The flag of if it is complete binary tree */ public boolean checkIfCompleteBinaryTree(BinaryTreeNode rootNode){ if(null == rootNode){ return false; } Queue&lt;BinaryTreeNode&gt; nodes = new LinkedList&lt;&gt;(); nodes.offer(rootNode); boolean startHavingEmptyChild = false; while(!nodes.isEmpty()){ BinaryTreeNode curNode = nodes.poll(); System.out.println(&quot;Pop Node:&quot;+curNode.getValue()); //If already there&apos;s node which has empty child, then this is not complete tree. if(startHavingEmptyChild &amp;&amp; (null == curNode.getLeftChild() || null == curNode.getRightChild())){ return false; } if(null != curNode.getLeftChild() &amp;&amp; null != curNode.getRightChild()){ nodes.offer(curNode.getLeftChild()); nodes.offer(curNode.getRightChild()); }else if(null != curNode.getLeftChild() &amp;&amp; null == curNode.getRightChild()){ startHavingEmptyChild = true; nodes.offer(curNode.getLeftChild()); }else if(null == curNode.getLeftChild() &amp;&amp; null != curNode.getRightChild()){ return false; }else{ startHavingEmptyChild = true; } } return true; } 四. 代码本文中所有代码，可访问Github获取：BinaryTreeAlgorithms.java 五. 参考文献 各种排序算法总结 二叉树 轻松搞定面试中的二叉树题目]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表相关算法]]></title>
    <url>%2Fzh-Hans%2F2017%2F10%2F02%2F%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一. 简介根据维基百科的定义：链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。 二. 实际应用根据链表结构插入和删除效率特别高的特点，链表主要用于插入和删除数据比较频繁并要求高效率的场景，比如： 操作系统的文件系统管理和内存池等。 内存数据库Redis中就有多个功能（发布与订阅、慢查询、监视器等）用到了无环双向链表。 版本管理系统Git的很多操作也是基于链表。merge和rebase等操作就是直接将链表指针移动到对应的branch所对应的node。 还有一些场景中，如果对使用线性表的长度和规模无法预测和控制时，会改为使用链表，比如通讯录等。 三. 常见算法本文中所有的单向链表和双向链表的结构定义如下： //单向链表 public class Node { private int value; private Node next; ... } //双向链表 public class DoublyNode { private int value; private DoublyNode previous; private DoublyNode next; ... } 1. 在O(1)时间删除链表节点题目描述： 给定链表的头指针和一个节点指针，在O(1)时间删除该节点。 分析： 本题主要思想是用下一个节点数据覆盖要删除的节点，然后删除下一个节点。如果待删除节点是尾节点时，直接删除该节点即可, 但是需要注意的是，这种情况下时间复杂度是O(N)而不是O(1)。 代码如下： /** * Given a linked list, delete the node in O(1) time complexity. * @param headNodeBeforeDeletingNode The source head node of the linked list * @param nodeToBeDeleted The node need to be deleted. * @return The head node of the linked list after deleting the node. */ public Node deleteNodeInO1TimeComplexity(Node headNodeBeforeDeletingNode, Node nodeToBeDeleted) { if(null == headNodeBeforeDeletingNode || null == nodeToBeDeleted){ System.out.println(&quot;The source linked list or the node to be deleted is null, will do nothing!&quot;); return headNodeBeforeDeletingNode; } if(null == nodeToBeDeleted.getNext()){ //Note: Here if the node need to be removed is the last node of the list, we will //not be able to delete it in O(1) time complexity, it&apos;s gonna to be O(N). Node tempNode = headNodeBeforeDeletingNode; while(tempNode.getNext() != null){ if(tempNode.getNext().equals(nodeToBeDeleted)){ tempNode.setNext(null); return headNodeBeforeDeletingNode; } tempNode = tempNode.getNext(); } }else{ Node nextNode = nodeToBeDeleted.getNext(); nodeToBeDeleted.setValue(nextNode.getValue()); nodeToBeDeleted.setNext(nextNode.getNext()); } return headNodeBeforeDeletingNode; } 2. 单链表的转置(transpose)题目描述： 输入一个单向链表，输出逆序反转后的链表 分析： 用两个辅助指针 pre、next 在链表上循环一遍即可 代码如下： /** * Transpose the linked list to a reverse order. * @param headNodeOfSourceList The head node of the source linked list * @return The head node of the transposed linked list. */ public Node transposeLinkedList(Node headNodeOfSourceList){ if(null == headNodeOfSourceList || headNodeOfSourceList.getNext() == null){ System.out.println(&quot;The source linked list is null or only has 1 element, will do nothing!&quot;); return headNodeOfSourceList; } Node pre = null; Node next = null; Node cur = headNodeOfSourceList; while(cur != null){ next = cur.getNext(); cur.setNext(pre); pre = cur; cur = next; } return pre; } 3. 求链表倒数第k个节点题目描述： 输入一个单向链表，输出该链表中倒数第k个节点，链表的倒数第0个节点为链表的尾指针。 分析： 设置两个指针 p1、p2，首先 p1 和 p2 都指向 head，然后 p2 向前走 k 步，这样 p1 和 p2 之间就间隔 k 个节点，最后 p1 和 p2 同时向前移动，直至 p2 走到链表末尾。 代码如下： /** * Given a linked list and a int k(between 1 and length of list), get the last K node. * @param headNodeOfSourceList * @param k The int k(between 1 and length of list) * @return The last k node */ public Node getLastKNodeOfTheLinkedList(Node headNodeOfSourceList, int k){ Node position1 = headNodeOfSourceList; Node position2 = headNodeOfSourceList; int j = k; //First, move position2 to the k-th element of the list. while(j &gt; 1){ position2 = position2.getNext(); j--; } //Then move both position1 and position2 forward, when position2 reach end, // position1 is the last k-th element. while(position2.getNext() != null){ position1 = position1.getNext(); position2 = position2.getNext(); } return position1; } 4. 求链表的中间节点题目描述： 求链表的中间节点，如果链表的长度为偶数，返回中间两个节点的任意一个，若为奇数，则返回中间节点。 分析： 此题的解决思路和第3题「求链表的倒数第 k 个节点」很相似。可以先求链表的长度，然后计算出中间节点所在链表顺序的位置。但是如果要求只能扫描一遍链表，如何解决呢？最高效的解法和第3题一样，通过两个指针来完成。用两个指针从链表头节点开始，一个指针每次向后移动两步，一个每次移动一步，直到快指针移到到尾节点，那么慢指针即是所求。 代码如下： /** * Given a linked list, get the middle node of the list: * If the length is odd, return the middle; else return any of the middle 2 node. * @param headNodeOfSourceList * @return The middle node */ public Node getMiddleNodeOfTheLinkedList(Node headNodeOfSourceList){ Node position1 = headNodeOfSourceList; Node position2 = headNodeOfSourceList; //Then move both position1 and position2 forward, when position2 reach end, // position1 is the last k-th element. while(position2 != null &amp;&amp; position2.getNext() != null){ position1 = position1.getNext(); position2 = position2.getNext().getNext(); } return position1; } 5. 判断单链表是否存在环题目描述： 输入一个单向链表，判断链表是否有环。 分析： 通过两个指针，分别从链表的头节点出发，一个每次向后移动一步，另一个移动两步，两个指针移动速度不一样，如果存在环，那么两个指针一定会在环里相遇。 p作为指针从表头结点开始以1为步长遍历，边遍历边将表反向，如果p遇到NULL，则说明表没有环；如果p最后等于head，则说明表有环。 利用一个List和一个指针p，从头结点出发，依次判断每个节点的指针是否存在于List中，如果存在则表示有环，且p就是环的入口点，否则循环结束后p==null，没有环； 代码如下： 以下为使用方法1的代码： /** * Given a linked list, check if it has circle: * @param headNodeOfSourceList * @return The flag of if it has circle */ public boolean checkIfLinkedListHasCircle(Node headNodeOfSourceList){ Node position1 = headNodeOfSourceList; Node position2 = headNodeOfSourceList; //Then move both position1 and position2 forward, if position2 reach null means no circle, // else position2 will catch up with position1 when there is circle. while(position2 != null &amp;&amp; position2.getNext() != null){ position1 = position1.getNext(); position2 = position2.getNext().getNext(); if(position1.equals(position2)){ return true; } } return false; } 6. 找到环的入口点题目描述： 输入一个单向链表，判断链表是否有环。如果链表存在环，如何找到环的入口点。 分析： 简单的方法: 类似于判断是否单链表中存在环，使用其中的方法3，利用一个List和一个指针p，从头结点出发，依次判断每个节点的指针是否存在于List中，如果存在则表示有环，且p就是环的入口点 双指针的方法 h是链表起始点，s是环入口，p是两个指针碰撞点。r表示环的长度，r = x+y.可以证明， a = y + mr （头指针 到 环入口的距离 = 碰撞点p 到 环入口的距离 + 循环多次环 ）。证明如下：当fast若与slow相遇时，slow肯定没有走遍历完链表，而fast已经在环内循环了n圈(1&lt;=n)。假设slow走了s步，则fast走了2s步（fast步数还等于s 加上在环上多转的n圈），设环长为r，则： 2s = s + nr s= nr 设整个链表长L，入口环与相遇点距离为x，起点到环入口点的距离为a。 s = nr a + x = nr a + x = (n – 1)r +r = (n-1)r + r a = (n-1)r + r - x a = (n-1)r + y 由此可知，从链表头到环入口点等于(n-1)循环内环+ 相遇点到环入口点，于是我们从链表头、与相遇点分别设一个指针，每次各走一步，两个指针必定相遇，且相遇第一点为环入口点。 代码如下： 以下为使用方法1的代码： /** * Given a linked list, get the entry node of the circle if the linked list has circle. * Using 2 pointers * @param headNodeOfSourceList * @return The middle node */ public Node getCircleEntryNodeOfTheLinkedListWithCircle2(Node headNodeOfSourceList){ Node position1 = headNodeOfSourceList; Node position2 = headNodeOfSourceList; //Then move both position1 and position2 forward, when position2 reach end, // position1 is the last k-th element. while(position2 != null &amp;&amp; position2.getNext() != null){ position1 = position1.getNext(); position2 = position2.getNext().getNext(); } return position1; } 以下为使用方法2的代码： /** * Given a linked list, get the entry node of the circle if the linked list has circle. * Using 2 pointers * @param headNodeOfSourceList * @return The middle node */ public Node getCircleEntryNodeOfTheLinkedListWithCircle2(Node headNodeOfSourceList){ Node position1 = headNodeOfSourceList; Node position2 = headNodeOfSourceList; //Then move both position1 and position2 forward, when position2 reach end, // position1 is the last k-th element. while(position2 != null &amp;&amp; position2.getNext() != null){ position1 = position1.getNext(); position2 = position2.getNext().getNext(); if(position1.equals(position2)){ //先判断是否有环 break; } } //不存在环返回null if(!position1.equals(position2)){ return null; } //快指针重新从表头开始按照步长1走，与慢指针相遇的点就是环入口。 position2 = headNodeOfSourceList; while(!position1.equals(position2)){ position1 = position1.getNext(); position2 = position2.getNext(); } return position1; } 7. 编程判断两个链表是否相交题目描述： 给出两个单向链表的头指针（如下图所示），比如h1、h2，判断这两个链表是否相交。这里为了简化问题，我们假设两个链表均不带环。 分析： 解题思路： “如果两个没有环的链表相交于某一节点，那么在这个节点之后的所有节点都是两个链表共有的”这个特点，我们可以知道，如果它们相交，则最后一个节点一定是共有的。而我们很容易能得到链表的最后一个节点，所以这成了我们简化解法的一个主要突破口。那么，我们只要判断两个链表的尾指针是否相等。相等，则链表相交；否则，链表不相交。所以，先遍历第一个链表，记住最后一个节点。然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则，不相交。这样我们就得到了一个时间复杂度，它为O((Length(h1) + Length(h2))，而且只用了一个额外的指针来存储最后一个节点。这个方法时间复杂度为线性O(N)，空间复杂度为O(1) 代码如下： /** * Given 2 linked list, check if they intersect: * @param headNodeOfSourceList1 The head node of list 1 * @param headNodeOfSourceList2 The head node of list 2 * @return The flag of if the two linked list intersect */ public boolean checkIfLinkedListHasCircle(Node headNodeOfSourceList1, Node headNodeOfSourceList2){ if(headNodeOfSourceList1 == null || headNodeOfSourceList2 == null){ return false; } while(headNodeOfSourceList1.getNext() != null){ headNodeOfSourceList1 = headNodeOfSourceList1.getNext(); } while(headNodeOfSourceList2.getNext() != null){ headNodeOfSourceList2 = headNodeOfSourceList2.getNext(); } return headNodeOfSourceList1.equals(headNodeOfSourceList2); } 8. 两链表相交的第一个公共节点题目描述： 如果两个无环单链表相交，怎么求出他们相交的第一个节点呢？ 分析： 采用对齐的思想。计算两个链表的长度 L1 , L2，分别用两个指针 p1 , p2 指向两个链表的头，然后将较长链表的 p1（假设为 p1）向后移动L2 - L1个节点，然后再同时向后移动p1 , p2，直到 p1 = p2。相遇的点就是相交的第一个节点。 代码如下： /** * Get the lengh of the linked list * @param headNodeOfSourceList The head node of the linked list * @return The length of the linked list */ private int getLengthOfLinkedList(Node headNodeOfSourceList){ if(null == headNodeOfSourceList){ return 0; } int length = 0; while(headNodeOfSourceList != null){ headNodeOfSourceList = headNodeOfSourceList.getNext(); length++; } return length; } /** * Given 2 linked list, get the first common node of the 2 intersected linked list. * @param headNodeOfSourceList1 The head node of list 1 * @param headNodeOfSourceList2 The head node of list 2 * @return The intersect node of 2 linked list */ public Node getIntersectNodeOfTheTwoIntersectLinkedList(Node headNodeOfSourceList1, Node headNodeOfSourceList2){ int length1 = getLengthOfLinkedList(headNodeOfSourceList1); int length2 = getLengthOfLinkedList(headNodeOfSourceList2); //First move the longer linked list to the same size node postion as the other one if(length1 &lt; length2){ for(int i = 0; i &lt; length2 - length1; i++) { headNodeOfSourceList2 = headNodeOfSourceList2.getNext(); } }else{ for(int i = 0; i &lt; length1 - length2; i++) { headNodeOfSourceList1 = headNodeOfSourceList1.getNext(); } } //Then move both linked list forward, the first equal node is the intesect node while(null != headNodeOfSourceList1 &amp;&amp; !headNodeOfSourceList1.equals(headNodeOfSourceList2)){ headNodeOfSourceList1 = headNodeOfSourceList1.getNext(); headNodeOfSourceList2 = headNodeOfSourceList2.getNext(); } return headNodeOfSourceList1; } 四. 代码本文中所有代码，可访问Github获取：LinkedListAlgorithms.java 五. 参考文献 Jark’s Blog - 面试精选：链表问题集锦 链表- 维基百科 算法（十四）-单链表的环问题]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中文数字和阿拉伯数字的转换]]></title>
    <url>%2Fzh-Hans%2F2017%2F09%2F25%2F%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97%E5%92%8C%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[在微软的面试中遇到一个算法问题，要求将类似于”二十五万五百亿三千零八万一千零三十五”的中文数字转换成对应的阿拉伯数字。结果在面试中一味地想着用栈或者其他数据结构去实现，而没有仔细的分析具体问题和算法就开始写代码，导致完成的非常差劲。 一. 中文数字的特点： 包括零到九的基本数字 数量级文字：十、百、千、万、亿、兆、京。。。等。十百千不能连续出现，从万开始，数量级前缀其他数量级一起使用 二. 算法设计1.使用一个Map存储所有的数量级文字信息： /** * 数量级map，存储对应的数量级文字和对应的阿拉伯数字量值 * @return The operator map */ private static Map&lt;String,Long&gt; getMagnitudeMap(){ Map&lt;String,Long&gt; magnitudeMap = new HashMap(); magnitudeMap.put(&quot;十&quot;, 10l); magnitudeMap.put(&quot;百&quot;, 100l); magnitudeMap.put(&quot;千&quot;, 1000l); magnitudeMap.put(&quot;万&quot;, 10000l); magnitudeMap.put(&quot;亿&quot;, 100000000l); magnitudeMap.put(&quot;兆&quot;, 1000000000000l); magnitudeMap.put(&quot;京&quot;, 10000000000000000l); return magnitudeMap; } 使用另一个Map存储所有的基本数字信息： /** * 基本数据map，存储对应的基本数据及对应的阿拉伯数字量值 * @return The magnitude map */ private static Map&lt;String,Long&gt; getDataMap(){ Map&lt;String,Long&gt; dataMap = new HashMap&lt;&gt;(); dataMap.put(&quot;一&quot;,1l); dataMap.put(&quot;二&quot;,2l); dataMap.put(&quot;三&quot;,3l); dataMap.put(&quot;四&quot;,4l); dataMap.put(&quot;五&quot;,5l); dataMap.put(&quot;六&quot;,6l); dataMap.put(&quot;七&quot;,7l); dataMap.put(&quot;八&quot;,8l); dataMap.put(&quot;九&quot;,9l); dataMap.put(&quot;零&quot;,0l); return dataMap; } 2.从后往前遍历字符串，遇到数字的时候，如果是零直接跳过，否则将当前数字前一位数量级相乘并累加到sumvalue中。 /** * 从后往前遍历字符串的方式将中文数字转换为阿拉伯数字 * @param inputStr 源字符串 * @return 转换后的阿拉伯数字 * @throws Exception 如果字符串中有不能识别的（不在dataMap和operatorMap）字符，抛出异常 */ public long convertToLongFromEnd(String inputStr) throws Exception{ //存储遇到该数字前的最大一个数量值，这个值是累乘之前所有数量级， //比如二百万，到二的时候最高数量级就是100*10000 long currentMaxLevel = 1l; //存储之前一次执行过乘操作的数量级 long previousOpeMagnitude = 1l; //存储当前字符所对应的数量级 long currentMagnitude = 1l; //存储当前所有字符仲最大的单个字符的数量级， long maxMagnitude = 1l; long sumVal = 0l; int len = inputStr.length(); //倒序循环整个字符串，从最低位开始计算整个数值 for(int i=len-1;i&gt;=0;i--){ String currentTxt = String.valueOf(inputStr.charAt(i)); //如果当前值是数量级 if(magnitudeMap.containsKey(currentTxt)){ currentMagnitude = magnitudeMap.get(currentTxt); //如果第一位是一个数量级（比如十二）, 将当前值相加 if(i == 0){ sumVal = sumVal + currentMagnitude; return sumVal; } //比较当前数量级与当前最大数量值，如果大于当前最大值，将当然最大数量值更新为当前数量级 if(currentMagnitude &gt; currentMaxLevel){ currentMaxLevel = currentMagnitude; }else{ if(currentMagnitude &lt; maxMagnitude &amp;&amp; currentMagnitude &gt; previousOpeMagnitude){ //如果当前数量级小于当前最大数量级并且大于之前的数量级,比如二十五万五百亿，抵达&quot;万&quot;的时候因为之前的百 //已经与亿相乘，所以应该除以之前的百才能得到当前真正的最大数量值 currentMaxLevel = currentMaxLevel*currentMagnitude/previousOpeMagnitude; }else{ currentMaxLevel = currentMaxLevel*currentMagnitude; } previousOpeMagnitude = currentMagnitude; } //将当前最大单数量级更新为当前数量级 if(currentMagnitude &gt; maxMagnitude){ maxMagnitude = currentMagnitude; } }else if(dataMap.containsKey(currentTxt)){ //如果是0~9之间的数字，与前面一位数量级相乘，并累加到当前sumVal long data = dataMap.get(currentTxt); if(data == 0){ //跳过0 continue; }else{ sumVal = sumVal + data*currentMaxLevel; } }else{ throw new Exception(&quot;Find illegal character in the input string:&quot;+currentTxt); } } return sumVal; } 三. 代码及测试 相关代码详见：ChineseNumberConverter.java 单元测试详见：TestChineseNumberConverter.java]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Design Pattern 笔记 - 代理模式(Proxy Pattern)]]></title>
    <url>%2Fzh-Hans%2F2017%2F09%2F22%2FDesign-Pattern-Note-Proxy-Pattern%2F</url>
    <content type="text"><![CDATA[一. 定义代理模式(Proxy Pattern) ：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。代理模式的英 文叫做Proxy或Surrogate，它是一种对象结构型模式。 二. 常用场景1. 远程代理为对象在不同的地址空间提供局部代表，比如远程方法调用（RMI）利用代理模式，使得在其他 JVM 中执行的对象就像本地对象一样；企业 JavaBeans （EJB）利用代理模式添加远程调用、安全性和事务分界；而 JAX-RPC Web 服务则用代理模式让远程服务表现得像本地对象一样。代理可以用来提供远程控制（就像在 RMI、EJB 和 JAX-RPC 中那样），用安全性策略包装对象（EJB）、为昂贵的对象（EJB 实体 Bean）提供惰性装入，或者添加检测工具（例如日志记录）。 2. 图片代理一些网站或者程序中在显示图片列表时使用缩略图显示，只有在需要放大浏览或者下载时才访问真正的原图。 3. 保护代理可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限 4. 虚拟代理如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。比较典型的例子就是hibernate的延迟加载，Hibernate结合Javassist或CGLIB动态生成代理对象， 通过代理模式来“推迟”加载关联实体的时间，如果程序并不需要访问关联实体，那程序就不会去抓取关联实体。这样既可以节省系统的内存开销，也可以缩短 Hibernate 加载实体的时间。 5. 动态代理比较典型的应用场景： 缓存系统 spring AOP面向切面编程。 Spring中的事务管理 RMI在JDK 5后的版本也是使用动态代理生成stub对象。 单元测试中也使用动态代理来mock对象。 三. 优缺点1. 优点 代理模式可以在一定程度上降低系统的耦合度， 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系 统资源的消耗，对系统进行优化并提高运行速度。 保护代理可以控制对真实对象的使用权限。 通过在代理对象中添加业务逻辑来实现对一些系统统一行为的定制和扩展，从而能够更灵活地处理对原有对象的控制和访问。 2. 缺点 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢 实现代理模式需要额外的工作，有些代理模式的实现 非常复杂]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Red–black BST with no extra memory]]></title>
    <url>%2Fen%2F2017%2F05%2F16%2Fred-black-bst-with-no-extra-memory%2F</url>
    <content type="text"><![CDATA[I am in a couresa course for algorithm, and in the quiz there’s 1 question: Red–black BST with no extra memory. Describe how to save the memory for storing the color information when implementing a red–black BST. I saw some posts which are talking about using pointer(like c or c++ which support pointer) to store the color infomration. But for java, there’s no concept like pointer. So 1 solution is to modify the BST tree structure, using the different order to flag the color information: Red: Store the color information in the right side node of the red link, as chart below, store the information in node C/J/X. Using inverse order other than original BST tree, means put it’s larger child to left and smaller child to right for those nodes which store the color information. No matter it has 1 or 2 child, if the color is red, then use the inverse order, and use original order if it’s black. Since the node with red color always has at least 1 left child, then this structure will be able to store the color information without any extra memory cost.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L1 Visa renewal or extension?]]></title>
    <url>%2Fen%2F2016%2F10%2F11%2Fl1-visa-renewal-or-extension%2F</url>
    <content type="text"><![CDATA[For L1 visa, I got it at 2014-11-4 : expiration date as 2016-11-6, I-129S, expiration date as 2017-11-4 I-94, expiration date as 2019-11-4 I need to go back to China at 2016-12-3, and at the time my visa is going to be expired, and then when I come back to US at 2016-12-20, i will not able to entry. This problem is driving me crazy these sevral days. And finally I releaize it’s not a big deal. What i need to do is only the L1 VISA renewal. Here is what it means: Extension is the process of requesting extension of stay as well as work period in US. It is filed by filing I539 ( for extension of stay) and I129 (extension for petition to work). Now generally, all this achieves is the extension of I-94. USCIS would reject the request for extension if applied more than 6 Months before I-94 expiry stating that extension is not required as I am already allowed to stay and work till 2019. So I don’t need to file an extension now. 2.As for renewal, it typically means, getting a new visa in my passport. This can happen only outside US. I need to go to the consulate outside US, take interview appointment based on my DS-160, take the I129S, and I797, and supporting documents, and face the Visa Officer and if granted, would get a new L1 stamp in my passport. The advantage of renewal is that I get fresh visa and the freedom to enter US multiple times as long as visa is valid. &nbsp; &nbsp;]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSF 2 + Richfaces 4 + Seam]]></title>
    <url>%2Fen%2F2016%2F10%2F05%2Fjsf-2-richfaces-4-seam%2F</url>
    <content type="text"><![CDATA[In order to overwrite the default richfaces 4 ecss styles, from the document(https://docs.jboss.org/richfaces/latest/Developer_Guide/en-US/html_single/#sect-Developer_Guide-RichFaces_overview-Restrictions). You need to put it to &lt;h:body&gt; section:JSF does render resource links (stylesheets, scripts) in order of occurrence, thus if you add &amp;lt;h:outputStylesheet&amp;gt; to the &amp;lt;h:head&amp;gt;section, JSF will render it before the RichFaces resource links (dependencies of RichFaces components). To be able to overwrite RichFaces stylesheets and re-use RichFaces JavaScript implementation, you need to render &amp;lt;h:outputStylesheet&amp;gt; to the &amp;lt;h:body&amp;gt;section (safe solution is to place it on the end of the section; however to keep readability, you can use start of the section). &nbsp;]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Failed Again on H1B lottery]]></title>
    <url>%2Fen%2F2016%2F05%2F04%2Ffailed-again-on-h1b-lottery%2F</url>
    <content type="text"><![CDATA[Life is not always good. When god open a window for you, he might close the door! My 3rd time for H1B lottery failed again. What the f*!!!!]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美国费城买车小记]]></title>
    <url>%2Fzh-Hans%2F2016%2F04%2F28%2F%E7%BE%8E%E5%9B%BD%E8%B4%B9%E5%9F%8E%E4%B9%B0%E8%BD%A6%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今天终于完成了所有买车的流程，拿到Passat的钥匙和title。在美国呆了一年多，因为公司离住的地方很近，即使呆在这个『车轮上的国度』也一直只是靠走路。当然，另一个原因就是费城发达的公共交通。因为儿子即将过来读书，所以不得不买一辆车代步，以方便以后带儿子explore各种好吃好玩的地方。 整个过程花了大约两周时间，也看过四五辆车子，总体来说还算比较顺利。现在把这个过程记录下来，也算一种不错的经历。 在美国买车可以通过两种方式，从Dealer或者私人手上买车。从Dealer买车会相对放心一点，但是价格相对也会高很多。所以选择从私人买车。因为正值学生毕业季，身在费城这个很多大学很多华人留学生的城市，可供选择的车还是挺多的。 整个过程看了5辆车子，2012年的凯美瑞、2010年的Acua、2013年的Nissan Altima、2007年的奥迪A4还有2012年的Passat。寻找这些车子的信息主要是费城和北美这边几个大的华人论坛（北美微论坛、费城华人资讯网、美国同程网）和Craglist，最后发现信息最多的是北美微论坛，车子也是在这里看到车主的广告后联系购买的。 看了5两车子，前面几辆车子都有或多或少的一些问题。所以最后决定了买Passat。从看车到买车总共花了不到一周时间全部搞定： 约了原车主看车（原车主是个即将毕业的小伙子，住的很近而且国内的地址也离得很近，还是挺有缘分的）。当天试驾了一下，整体车况很不错，2012年高配的Passat SE，5 cyl，蓝牙、天窗、加热皮座椅等。驾驶感觉也不错。因为原车主由于毕业急着卖出去，所以给的价格也不是很高，基本上当天双方就定下来交易了。 美国买车前最好必须要做的一件事是查看Carfax和Autocheck报告。这两个报告记录了所有车子的信息，包括里程数，保养记录，是否有事故，之前有几任车主以及是不是之前这个车子被用来出租用。而且这两个公司的信息来源不同，记录的信息有时候也不全面，最好是都看一下。我看Camry的时候就是看到Carfax没有车祸记录而且是clean title所以准备买，结果后来发现Autocheck上记录了车祸记录，这样会影响买车时候的价格。Passat车子的Carfax和Autocheck全部是Clean的，所以很放心的就决定要买了。 因为手上现金不够，所以根据印度同事的建议，去DCU贷款（https://www.dcu.org/index.html）。DCU的贷款利率比各大银行利率都会低很多，而且如果Credit Score高的话，这个rate会很低。像我拿到的是2.99%的利率，如果是去BOA的话，这个肯定要5%以上。Online提交了我的各种信息，以及和车主签订的sales agreement还有车子title的扫描件，两个工作日之内就办完了贷款，然后使用FedEx的加急服务，贷款完成的第二天晚上就拿到了支票。这个支票是签给seller的，而且必须要seller和buyer两个人同时签名才能入账。 买车之前最好是去做一个merchanic check，周边很多连锁的店都可以做，比如Firestone。但是因为车主之前是从Dealer那里买的Certified Pre-Own车子，车况也比较好，所以就没有去做。 在Pennsvalnia，买车前还必须要做的一件事情就是去买Auto insurance。根据同事的推荐，在几个大的保险公司Geico、StateFarm、Progressive都拿了Quote。比较了一下还是Statefarm比较好。所以提供了自己的各种信息，电话里提供了信用卡信息和车子的VIN号码，几分钟就完成了保险的购买。6个月的policy，总共价格不到600刀。Agent立刻寄给我ID Card，以便第二天去办理过户。 和车主第二天去办理过户手续，因为听说人很多所以没有去DMV，就在家附近的Penn DOT授权的Agent那里办理，整个过程用了不到办个小时： 车主提供了title，registration，并且在title上面签好了自己的名字，报了车子的公里数 本人提供了有效宾州的驾照，保险的ID card，在title上签名 本来是想sign as gift，这样可以省掉8%的税。但是因为有贷款，所以就把价格报的和贷款数额一样，这样也省掉了大约500刀购置税。 除了税，其他的过户手续等大约花了150左右，拿到了新的车牌和registration。 将车子换好车牌，拿到车钥匙，全部交易完毕。&nbsp; &nbsp;]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript timezone issue with backend server in different zone]]></title>
    <url>%2Fen%2F2015%2F10%2F02%2Fjavascript-timezone-issue-with-backend-server-in-different-zone%2F</url>
    <content type="text"><![CDATA[Today I met an problem when doing the test in the server from different timezone: Client select a date(Say 2015-10-1 ) from the form, angular populate the datetime with new Date() from javascript and pass it to server. After saving the object and then display it, it’s displayed as ‘2015-9-30 23:00:00’. And every time after doing this, we have 1 hour difference.Then I realize this should be a timezone issue and check the document: “When populating the date and no timezone is specified, it default to use the local timezone from the client browser”. Since our QA server is from different timezone, we always has the 1 hour difference. Solution: We could have multiple solutions for this. But our requirement is pretty straightforward, we just want no matter which date the client selected, we have the same value saved to database. So I changed the value that we passed to server to be a string value(like ‘2015/10/1’) and parse the date from server side, instead of using the datatime long value. There also some other solution referred: http://www.techrepublic.com/article/convert-the-local-time-to-another-time-zone-with-this-javascript/ http://momentjs.com/timezone/docs/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EJB3.0 和 EJB2 的区别]]></title>
    <url>%2Fzh-Hans%2F2014%2F01%2F06%2FEJB3.0%20%E5%92%8C%20EJB2%20%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1. EJB2.0使用EntityBeans来访问数据库，EJB3.0是使用JPA（Java Persistance API）来访问数据库。 2. EJB2.0 有部署脚本(Deployment descriptiors),EJB3.0没有。 3. EJB3.0不需要Home接口，EJB2.0需要。 4. EJB3.0简化了开发，引入了元数据。 5. EJB2 限制开发人员无法在 EJB 容器外部测试 EJB 模块 ， EJB3可以更方便的使用JUnit等测试框架 6.EJB3 可以使用更多元化的SQL查询语言，包括native查询，而EJB2使用的是EJBQL。 7.EJB3的annotation的使用 8.EJB2中需要创建多个不必要的组件接口，而且要捕获一些不需要的异常信息，使用不太灵活]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>EJB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[儿子第一次用MSN和我的聊天记录]]></title>
    <url>%2Fzh-Hans%2F2011%2F08%2F19%2F%E5%84%BF%E5%AD%90%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%94%A8MSN%E5%92%8C%E6%88%91%E7%9A%84%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[140101m,,mmmmmmmmmmmmp010看过晕ti\9.5 不会呼唤 9 提议明年，， 男男女女男男女女男男女女男男女女年内能000000000000]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个句号引发的惨案]]></title>
    <url>%2Fzh-Hans%2F2011%2F04%2F01%2F%E4%B8%80%E4%B8%AA%E5%8F%A5%E5%8F%B7%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88%2F</url>
    <content type="text"><![CDATA[今天客户对之前做的东西做了一个修改，要求是：Please add a period to the end of the message. 看来看去，没想起来到底要加什么period。加一段日期进去？加什么日期呢？ 问了一下，客户回复：I mean the period（。） 靠，period原来还有句号的意思，这么多年英语白学了，还以为客户的需求没给明白，汗！]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nvarchar与varchar的区别]]></title>
    <url>%2Fzh-Hans%2F2010%2F11%2F29%2Fnvarchar%E4%B8%8Evarchar%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[nvarchar与varchar的区别&amp;lt;/p&gt; varchar[(n)]长度为 n 个字节的可变长度且非 Unicode 的字符数据。n必须是一个介于 1 和 8,000 之间的数值。存储大小为输入数据的字节的实际长度，而不是 n个字节。所输入的数据字符长度可以为零。varchar 在 SQL-92 中的同义词为 char varying 或character varying。 nvarchar(n)包含 n个字符的可变长度 Unicode 字符数据。n 的值必须介于 1 与 4,000之间。字节的存储大小是所输入字符个数的两倍。所输入的数据字符长度可以为零。nvarchar 在 SQL-92 中的同义词为national char varying 和 national character varying。&amp;amp;nbsp; 通俗一點就是varchar適合輸入英文和數字，nvarchar一般用做中文或其它語言的輸入，這樣到別的語系不會出現亂碼:))]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interceptor 中onFlushDirty()函数执行多次的问题（Hibernate 的一个小Bug）]]></title>
    <url>%2Fzh-Hans%2F2008%2F05%2F09%2FInterceptor%20%E4%B8%ADonFlushDirty()%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%A4%9A%E6%AC%A1%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88Hibernate%20%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8FBug%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近在项目中遇到一个奇怪的问题，在使用Hibernate拦截器捕获实体变化并进行处理时，发现其中的onFlushDirty()函数执行了很多次，导致进行处理时产生很多重复数据。具体问题如下：使用一个类继承Hibernate的EmptyInterceptor类来对程序中的实体变化进行拦截，并在其中的onFlushDirty()函数中对捕获的数据进行处理，产生对应的event数据并保存到数据库中。 例如：&lt;br /&gt;public class EventInterceptor extends EmptyInterceptor {public boolean onFlushDirty(Object entity,Serializable id,Object[] currentState,Object[] previousState,String[] propertyNames,Type[] types ) throws CallbackException { if(isAuditable(entity)){//如果该实体需要被记录，生成对应的event。&lt;br /&gt;//此处生成对应的event。&lt;br /&gt;}return false;} 在程序执行后，发现对应一条实体的变化生成了多条重复的event记录，非常不解。&lt;br /&gt;后来google发现，有人也碰到过对应的问题，并在Hibernage论坛中提出过这个问题，鉴定为Hibernate的一个小Bug。&lt;br /&gt;（原文地址：http://forum.hibernate.org/viewtopic.php?t=940410&amp;highlight=interceptor+onflushdirty）&lt;br /&gt;解决方法如下：&lt;br /&gt;将FlushMode改为：FlushMode.COMMIT或者也可以提前进行flush()都可以解决这个问题。&lt;br /&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql server 中删除默认约束的通用sql脚本]]></title>
    <url>%2Fzh-Hans%2F2008%2F04%2F17%2Fsql%20server%20%E4%B8%AD%E5%88%A0%E9%99%A4%E9%BB%98%E8%AE%A4%E7%BA%A6%E6%9D%9F%E7%9A%84%E9%80%9A%E7%94%A8sql%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[作者： sealyu 日期：2008-04-17在SQL Server 中，如果给表的一个字段设置了默认值，就会在系统表sysobjects中生成一个默认约束。&lt;br /&gt;如果想删除这个设置了默认值的字段（假设此字段名column1），执行“ALTER TABLE table1 DROP COLUMN column1”时就会报错：The object ‘DF__xxxxxxxxxxx’ is dependent on column ‘column1’.ALTER TABLE DROP COLUMN column1failed because one or more objects access this column. 所以在删除此字段时需要先将系统表中的对应默认约束删除， 可以使用下面的脚本进行删除：– this script drops the default constraint which is generated by the setting of default value.DECLARE @tablename VARCHAR(100), @columnname VARCHAR(100), @tab VARCHAR(100)SET @tablename=’CountryGroupEmailAndWaitAux’SET @columnname=’actionOfHasNoValidEmail’ declare @defname varchar(100)declare @cmd varchar(100) select @defname = nameFROM sysobjects soJOIN sysconstraints scON so.id = sc.constidWHERE object_name(so.parent_obj) = @tablenameAND so.xtype = ‘D’AND sc.colid =(SELECT colid FROM syscolumnsWHERE id = object_id(@tablename) ANDname = @columnname) select @cmd=’alter table ‘+ @tablename+ ‘ drop constraint ‘+ @defnameif @cmd is null print ‘No default constraint to drop’exec (@cmd) 在删除对应的默认约束后，执行：&lt;br /&gt;ALTER TABLE table1 DROP COLUMN column1即可删除字段。&lt;br /&gt;]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
</search>
